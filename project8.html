<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CppMjStep: Extended Custom Autograd Function for Differentiable MuJoCo Dynamics</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f9f9f9;
      color: #333;
    }

    .container {
      max-width: 1000px;
      margin: 20px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }

    h1 {
      color: #1E90FF;
      margin-bottom: 20px;
    }

    p {
      line-height: 1.6;
    }

    .navigation-buttons {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }

    .navigation-buttons button {
      background-color: #1E90FF;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 1rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .navigation-buttons button:hover {
      background-color: #187bcd;
    }

    .slideshow-container {
      max-width: 1000px;
      position: relative;
      margin: auto;
    }

    .mySlides {
      display: none;
    }

    .center {
      width: 100%;
      height: 600px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .center img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .numbertext, .text {
      position: absolute;
      width: 100%;
      text-align: center;
      padding: 8px 12px;
    }

    .numbertext {
      top: 0;
      font-size: 12px;
      color: #000;
    }

    .text {
      bottom: 8px;
      font-size: 15px;
      color: #000;
    }

    .dot-container {
      text-align: center;
      padding: 15px 0;
    }

    .dot {
      height: 12px;
      width: 12px;
      margin: 0 4px;
      background-color: #bbb;
      border-radius: 50%;
      display: inline-block;
      transition: background-color 0.6s ease;
    }

    .active {
      background-color: #717171;
    }

    .fade {
      animation: fade 1.5s;
    }

    @keyframes fade {
      from {opacity: 0.4} 
      to {opacity: 1}
    }

    @media (max-width: 600px) {
      .navigation-buttons {
        flex-direction: column;
        align-items: center;
      }

      .navigation-buttons button {
        width: 100%;
      }

      .center {
        height: 400px;
      }

      .text, .numbertext {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="navigation-buttons">
      <button onclick="location.href='project7.html'"><i class="fa fa-arrow-left"></i> Prev project</button>
      <button onclick="location.href='index.html'"><i class="fa fa-home"></i> Home</button>
      <!-- <button onclick="location.href='project8.html'">Next project <i class="fa fa-arrow-right"></i></button> -->
    </div>

    <header>
      <h1>CppMjStep: Extended Custom Autograd Function for Differentiable MuJoCo Dynamics</h1>
      <p>
        I built CppMjStep to make MuJoCo differentiable inside PyTorch without slowing everything down. It is a C++ autograd extension that lets me backpropagate through entire simulation rollouts, supports batched runs, and includes sensor gradients so models that rely on IMU or force data can train end to end. The core is multithreaded C++ for speed and it is pip installable. In my benchmarks, large models with big batch sizes see more than a 2x speedup compared with a Python approach. <br> <br>

        Using it feels like a regular PyTorch layer. You pass a MuJoCo model and data, pick the number of steps to unroll, and call the module to step the dynamics while keeping everything in the computational graph. The repo notes MuJoCo 3.1.2 state size requirements and credits DiffMjStep as inspiration, with added support for sensors and multithreading. The goal is simple, make gradient based control and system identification in MuJoCo fast enough for real experiments. <br> <br>

        The GitHub repo is available <a href="https://github.com/mukundan-chariar1/CppMjStep" target="_blank" rel="noopener noreferrer">here</a>.
            </p>
    </header>

    <div class="slideshow-container" id="slideshow">
      <!-- Slides will be inserted via JavaScript -->
    </div>

    <div class="dot-container" id="dots"></div>
  </div>

  <script>
    const imageCount = 4;
    const captions = [
      "Execution time for models with no sensors", "Execution time for models with no sensors (Python v/s C++)", 
      "Execution time for models with sensors", "Execution time for models with no sensors (Python v/s C++)"
    ];

    const slideshow = document.getElementById("slideshow");
    const dotsContainer = document.getElementById("dots");

    for (let i = 1; i <= imageCount; i++) {
      slideshow.innerHTML += `
        <div class="mySlides fade">
          <div class="numbertext">${i} / ${imageCount}</div>
          <div class="center">
            <img src="images/project8/${getImageName(i)}">
          </div>
          <div class="text">${captions[i - 1]}</div>
        </div>`;
      dotsContainer.innerHTML += `<span class="dot"></span>`;
    }

    function getImageName(i) {
      const names = [
        "execution_time_no_sensors_all", "execution_time_py_vs_cpp_no_sensors", "execution_time_sensors_all", "execution_time_py_vs_cpp_sensors"
      ];
      return `${names[i - 1]}.svg`;
    }

    let slideIndex = 0;
    const slideTimes = Array(imageCount).fill(2000);
    showSlides();

    function showSlides() {
      const slides = document.getElementsByClassName("mySlides");
      const dots = document.getElementsByClassName("dot");

      for (let i = 0; i < slides.length; i++) {
        slides[i].style.display = "none";
        dots[i].classList.remove("active");
      }

      slideIndex++;
      if (slideIndex > slides.length) slideIndex = 1;

      slides[slideIndex - 1].style.display = "block";
      dots[slideIndex - 1].classList.add("active");

      setTimeout(showSlides, slideTimes[slideIndex - 1]);
    }
  </script>
</body>
</html>